# Blockchain

Created: 2018-04-01 21:58:10 +0500

Modified: 2022-03-14 20:48:37 +0500

---

Inventor - Satoshi Nakamoto
"Most technologies tend to automate workers on the periphery who are doing menial tasks. But blockchains automate away the center. Instead of putting taxi drivers out of a job, blockchain puts Uber out of a job, and lets the taxi drivers work with the customer directly." --- Vitalik Buterin, Creator of Ethereum
A blockchain is a data structure that enables identifying and tracking transactions digitally and sharing this information across a distributed network of computers, creating a distributed trust network.
**Key Points**
-   Trapdoor function

A trapdoor function is a function that is easy to compute in one direction but difficult to compute in the opposite direction unless you have special information. Trapdoor functions are essential for public key encryption---that's why they are commonly used in blockchain development to represent the ideas of addresses and private keys.-   Chain Fork

Blocks in the ledger are included in such a way as to build the longest chain, i.e., the chain with the greatest cumulative difficulty. Forking is a situation where there are two candidate blocks competing to form the longest blockchain and two miners discover a solution to the proof-of-work problem within a short period of time from each other. The network is then divided, because some nodes get blocks from miner #1 and some from miner #2.

A fork usually gets resolved in one block, because the probability that this situation happens again gets extremely lower with the next blocks that arise, so soon there is a new longest chain that will be considered as main.

(Note: This type of fork is distinct from ahard fork, which is where some developers decide to create a backward-incompatible change to the blockchain protocol, resulting in two forever-distinct blockchains.)
**Featues of Blockchain**
-   Distributed / Decentralized - Data is replicated on all the nodes in a distributed P2P network, and each copy of the ledger is identical to others. It can also be decentralised with some lighter nodes not having full data storage with limited connection.
-   Consensus mechanism - All users in the network can come to a pre-determined programmable agreement on the method of validation and can be by consensus.
-   Irreversibility and crypto security - One would need to command at least 51% of the computing power (or nodes or stake) to take control of the bitcoin blockchain.
-   Cryptographically secure - That means that the minting of digital currency is secured by mathematical algorithms that make it very difficult to break. It prevents bad actors from creating fake transactions, erasing transactions, stealing funds, etc.
-   Finite-state machines - In Computer Science, a state machine is a machine that will analyze a series of inputs and based on those inputs will transition to a new state. Blockchains have one instance responsible for all the transactions being created by the system. There's one global truth that all nodes adhere to, they all share the same state.
**Points**
-   Blockchains all start with a 'genesis state'.
-   Each transaction in the Ethereum network is grouped into what are called blocks. A single block contains a set of transactions and each block points to the next block. This makes a chain of blocks aka blockchain.
-   Mining is when a specific group of nodes (miners) uses their computing power to create a block of valid transactions.
-   The processes of validating each block by having a miner provide a mathematical proof are called the 'proof of work' algorithm.
-   Miners who validate new blocks get rewarded with an intrinsic digital token called 'Ether'. Every single time a miner proves a block as valid, the network generates new Ethers and awards the miner.
-   In scenarios where multiple paths are generated by miners, a 'fork' happens. Forks are to be avoided since they are disruptive to the system and force nodes to choose which chain they believe to be the most valid.
-   Ethereum's mechanism to choose the most valid chain is called the "GHOST protocol". GHOST stands for "Greedy Heaviest Observed Subtree". Essentially, it picks the path that has had the most computation done on it. The protocol uses the block number of the most recent block, this represents the total number of blocks in the current path. The higher the block number, the longer the path and as such the larger the mining effort that had to have gone into arriving at the most recent block. This allows the network to agree on the correct version of the current state.
**Components**
-   Accounts
    -   Externally Owned Account
        -   Ether Balance
    -   Smart Contract Account
        -   Ether Balance
        -   Contract Code
    -   Every account has a state
        -   nonce
            -   represents number of transactions sent from the address of the account
        -   balance
            -   amount of Ether owned by the address
        -   storageRoot
            -   root node of its Merkle tree
        -   codeHash
            -   hash of the Ethereum Virtual Machine code
    -   Merkle Tree

A Merkle tree is a type of binary tree composed of a set of nodes with lots of leaf nodes at the bottom of the tree that contains data. Intermediate nodes in a Merkle tree consist of nodes that have a hash of its two child nodes, and the root node is made up of the hash of its two child nodes, representing the top of the tree.

![](media/Blockchain-image1.png)
Data at the bottom of the Merkle tree is generated by splitting it into chunks, splitting chunks into buckets, and repeating the process using bucket hashes until there is only a single hash remaining (the root hash).
![usw ](media/Blockchain-image2.png)
Each node of the tree has a key with an associated value; the key tells us which child node to follow to get to the corresponding value, which is stored in the leaf nodes. In the case of ethereum, the key/value mapping for the state tree is between the addresses and their accounts.

Every blocks header stores the hash of the root node of what are essentially three different Merkle tree structures for the state, transactions, and receipts.
![Block 124 State root Txgroup root Block 125 State root Txgroup root Block 126 State root "662 Txgroup root Shard 10: state: Ret e g mot : . state 835680« Receipt Of57 ](media/Blockchain-image3.png)
Merkle trees are supremely useful because its a very efficient way to store all this information, especially for light nodes. Ethereum uses light nodes and full nodes; full nodes must download the full blockchain, executing all the transactions contained in it. Light nodes must download only the chain of headers, without needing to execute any transactions or retrieving any associated state. This allows them to easily generate and receive verifiable answers about balances, events, etc.

Merkle trees serve to help secure the blockchain because hashes in the Merkle tree propagate upward. If a bad actor tries to swap a fraudulent transaction into the bottom of the Merkle tree, it will cause a chain reaction in all the hashes in all the nodes above it.
![2f9c 48a5 1328 d187 d063 a8b5 48a5 d8ca 94 bc 4a2f 2f9c d063 ERROR: hash(94bC •a8b5) d8Ca a8b5 d8ca e74b 12c5 20 BTC 1328 d187 Alice E« 20 BTC ](media/Blockchain-image4.png)
A node that wants to verify some data can use whats called a 'Merkle proof". This contains some data to be verified, the root hash of the tree, and the tree branch (partner hashes going up along the path from the data chunk to the root hash). People who read the proof can verify that branch hashing is consistent throughout the tree.-   **Fees**
    -   Every single computation/transaction on the Ethereum blockchain requires a fee. That fee is paid in whats called 'gas'. Gas is the unit Ethereum uses to measure computation fees. Gas price is an amount of Ether a node is willing to spend on every gas unit, measured in 'gwei' (since 'wei' is the smallest unit of Ether).
    -   For each transaction, a sender sets a gas limit and a gas price. The gas limit represents the maximum gas the sender is willing to pay. If the sender doesn't provide the necessary gas to execute a transaction, the transaction is considered invalid. And since the Ethereum network had to expend computational effort to run the calculations before running out of gas, none of the gas gets refunded to the sender. The money spent on gas by the sender is sent to some miners address since miners are expanding the computational effort to validate transactions. The gas fee acts as a reward for the miners. Importantly, gas is used to pay for storage usage as well.
    -   Fees help prevent users from overtaxing the Ethereum network. Its very computationally expensive to run computational steps on the Ethereum Virtual Machine, so smart contracts should be used for simple tasks like verifying ownership instead of more complex tasks like machine learning or file storage. Fees also help protect the network from malicious attacks. Ethereum has its own Turing complete programming language called Solidity for creating smart contracts. Turing complete means it can simulate any computer algorithm. It allows for-loops, so a bad actor could disrupt the network by executing an infinite loop within a transaction, but thanks to fees this becomes infeasible.
    -   There are two types of transactions in Ethereum, the message call and the contract creation (creates new smart contracts). Both are initiated by externally owned accounts and submitted to the blockchain. They are what bridge the external world to the internal state of Ethereum. Contracts can talk to other contracts via messages. Messages are like internal transactions. These messages are generated by contracts, and when one contract sends a message to another, the code that exists on the recipient contract account is executed.-   **Ethereum Virtual Machine**

![EVM ROM](media/Blockchain-image5.png)
The EVM is a complete virtual machine, and its only limitation is that its bound by gas. Meaning the total amount of computation it can do is limited by the amount of gas provided. Its a stack-based architecture (last-in, first-out). It has temporary memory and long-term storage. It even has its own language! (called EVM bytecode). When we write smart contracts, it's in a higher level language like Solidity, but this compiles down to EVM bytecode.
**Hyperledger**

Hyperledger is an open source community focused on developing a suite of stable frameworks, tools and libraries for enterprise-grade blockchain deployments.
It serves as a neutral home for various distributed ledger frameworks including Hyperledger Fabric, Sawtooth, Indy, as well as tools like Hyperledger Caliper and libraries like Hyperledger Ursa.
<https://www.hyperledger.org/>
**Hyperledger Fabric**

**Type: Distributed ledger software**
Hyperledger Fabric is intended as a foundation for developing applications or solutions with a modular architecture. Hyperledger Fabric allows components, such as consensus and membership services, to be plug-and-play. Its modular and versatile design satisfies a broad range of industry use cases. It offers a unique approach to consensus that enables performance at scale while preserving privacy.
<https://www.hyperledger.org/use/fabric>
Below are some of the key features of Hyperledger Fabric and what differentiates it from other distributed ledger technologies
-   Permissioned architecture
-   Highly modular
-   Pluggable consensus
-   Open smart contract model --- flexibility to implement any desired solution model (account model, UTXO model, structured data, unstructured data, etc)
-   Low latency of finality/confirmation
-   Flexible approach to data privacy : data isolation using 'channels', or share private data on a need-to-know basis using private data 'collections'
-   Multi-language smart contract support: Go, Java, Javascript
-   Support for EVM and Solidity
-   Designed for continuous operations, including rolling upgrades and asymmetric version sup-port
-   Governance and versioning of smart contracts
-   Flexible endorsement model for achieving consensus across required organizations
-   Queryable data (key-based queries and JSON queries)
[Blockchain 102 and The Dark Side of Blockchain](https://www.youtube.com/watch?v=-so3AtnToek)

**Proof of Authority (PoA)**
-   Blocks must be signed by a sufficient quorum of "authoritative" nodes
-   Very simple,, very efficient
-   Requires trust in the authorities
    -   How are they chosen?
-   Basically: A PKI, a databases, and a hashchain in a trenchcoat
-   Standard construction for "private"/"permissioned" blockchains
**Proof of Stake**
-   Like PoA, but authority is indirectly established by "stake", suh as token holdings
-   May offer integrated punishement mechanism for malicious nodes: slashing
-   Current **holy grail** to get of the nergy waste stigma (both Ethereum and IOTA plan to pivot to PoS)
-   Slight problems
    -   How is stake initally distributed?
        -   Popular: Sale of tokens
        -   Alternative: Bootstrap off of existing blockchains
    -   No built-in defence against centralization. No Sybil resistance
        -   Even if bootstrapped correctly, may become centralized without any visible sign
**Proof of Storage**
-   Example: Chia (2018)
    -   Increased wear destroys SSDs after less than a year
    -   No use beyond price speculation
**Proof of Elapsed Time (2016)**
-   Instead of computing hashes for PoW, just do: nothing! Go to sleep!
-   Incredible enery savings compared to PoW
-   Drop-in solution, behaves exactly like PoW
-   Used in permissioned environments
-   Small questions: What guarantees do other nodes have that no node wakes up before its time?
    -   Intel SGX
-   See also: Proof of Luck (PoL)
**mobilecoin (2020): Proof of complexity**
-   Mobile-device focused
-   Pulls every cryptographic register there is
    -   Stellar consensus
    -   Zero-knowledge proofs for everything
    -   Ristretoo, Schnorr anonymous signatures, Pedersen commitments
-   Security against double-spending completely relies on Intel SGX enclaves
-   Entire token supply is pre-mined
**DAO - Decentralized Autonomous Organization**
-   Governance implemented in Ethereum smart contracts. **Code is Law**, etc
-   Own token: DAO
-   Crowdfunding in June 2016: $150 million
-   Vulnerability in the split function: time-of-check/time-of-use vs recursive calls
    -   Anyone can propose to create a child DAO
    -   Contract first retrieves Ether from main DAO, then checks against proponent balance
    -   Recursive call allows this to be nested/magnified
    -   Mid June 2016: $60 million worth in rogue child DAO
    -   Build in 48 day period before funds can be transferred out
-   Heated discussion led to hard fork of the entire Ethereum Blockchain
**ERC-20 tokens**
-   Principal mechanism to create custom money-like tokens on Ethereum
-   Specifies a smart contract API that allows balance query and transfer of amounts
-   All details (ICO, governance, etc) left to the creator of the contract
-   May have own value independent of Ether, traded on several different platforms
**Crypto-enabled financial trickery**
-   Smart contracts allow automatic execution of contract stipulations, no matter their form
-   Classic: Arbitrage between different platforms
-   New: Uncollateralized flash loans
**Decentralized Finance - DeFi**
-   Allow most operations traditional financial instruments, but on The Blockchain
    -   Borrowing, Lending
    -   Price speculation
    -   Swapping once ERC-20 token for another
        -   F.e. Uniswap
**Self-soverign identities (SSI)**
-   Self-sovereign identity (SSI) is an approach to digital identity that gives individuals control of their digital identities
-   No single standard, specification, or shared understanding **what** that may be
**Oracle problem**
-   Cryptography works only within the system
-   Any interface to the real world requires trust in a node other than self
    -   In which case no distributed consensus is required
-   Cryptocurrencies have, more or less by definition, only one use case: **Ponzi schemes and other scams**
-   A pure timestamping hash chain/Merkle tree (without consensus overhead) can be useful
![Start Can i trust them to accurately report sensor data to the distributed ledger interface? yes I can trust them to accurately report sensor data to a Rain Old Database interface. oon•t need consensus. NO j can't trust them. The ' distributed ledger isn•t going to help with that. ](media/Blockchain-image6.jpg)
<https://blog.chain.link/what-is-the-blockchain-oracle-problem/>
