# Design Patterns

Created: 2019-01-11 16:13:23 +0500

Modified: 2020-08-05 00:06:11 +0500

---

1. **Foundational Patterns**

    a.  Distributed Primitives

    b.  Predictable Demands

    c.  Dynamic Placement

    d.  Declarative Deployment

    e.  Observable Interior

    f.  Life Cycle Conformance

2. **Behavioral Patterns**

    a.  Batch Job

    b.  Scheduled Job

    c.  Daemon Service

    d.  Singleton Service

    e.  Self Awareness

3. **Structural Patterns (**multi-container pods)

    a.  **Sidecar**

Similar to a sidecar on a motorcycle, it does not provide the main power, but it does help carry stuff. A sidecar is a secondary container which helps or provides a service not found in the primary application. Logging containers are a common sidecar

The idea for a sidecar container is to add some functionality not present in the main container. Rather than bloating code, which may not be necessary in other deployments, adding a container to handle a function such as logging solves the issue, while remaining decoupled and scalable. Prometheus monitoring and Fluentd logging leverage sidecar containers to collect data.

2. Initializer

3. **Ambassador**

This type of secondary container would be used to communicate with outside resources, often outside the cluster. Using a proxy, like Envoy or other, you can embed a proxy instead of using one provided by the cluster. It is helpful if you are unsure of the cluster configuration.

[Ambassador](https://www.getambassador.io/)is,"an open source, Kubernetes-native API gateway for microservices built on Envoy".

It allows for access to the outside world without having to implement a service or another entry in an ingress controller: proxy local connection, reverse proxy, limits HTTP requests, re-route from the main container to the outside world.

4. **Adapter**

This type of secondary container is useful to modify the data generated by the primary container. For example, the Microsoft version of ASCII is distinct from everyone else. You may need to modify a datastream for proper use.

The basic purpose of an adapter container is to modify data, either on ingress or egress, to match some other need. Perhaps, an existing enterprise-wide monitoring tools has particular data format needs. An adapter would be an efficient way to standardize the output of the main container to be ingested by the monitoring tool, without having to modify the monitor or the containerized application. An adapter container transforms multiple applications to singular view.

4. **Configuration Patterns**

    a.  EnvVar Configuration

    b.  Configuration Resource

    c.  Configuration Template

    d.  Immutable Configuration

5. **Advanced patterns**
